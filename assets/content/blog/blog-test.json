{
  "title": "Blog test",
  "date": "2021-02-24T14:50:50.798Z",
  "description": "Ipsa natus aliquid ",
  "body": "## some Post\n\n### Some subheader\n\nLorem ipsum dolor websites amet.\n\n> A blockquote from a wise person.\n\n# Why is JS so weird\n\nAs far as I understand it (and this is more of an attempt at me\nexplaining it to myself than anything else) JS is weird by design, as it\nwas conceived as a tool to make the web interactive. \n\nLooking through the LearnCode.academy Youtube Videos about this topic,\nthere are 5 language quirks that make it incredible \n\nI found this playlist that gives a quick explanation on 5 elements of js:\n[Playlist](https://www.youtube.com/watch?v=JEq7Ehw-qk8)\n\n\n1. **Functions are Objects**\n1. **JS is Event-Driven**\n1. **JS keeps its state in Memory after a Function has been executed (Closure)**\n1. **Scope** allows you to access data declared in the memory of the\nparent.\n\nThe following is an attempt to explain this to myself.\n\n## Functions are objects in Javascript\nActually, almost everything is an object in JavaScript. Arrays are\nobjects and functions are objects. That makes it so you can declare a\nfunction in many different ways i.e.\n```js\nfunction regularFunction(){\n\tconsole.log(\"regularFunction\")\n\t}\n\nvar functionExpression = function(){\n\tconsole.log(\"functionExpression\")\n\t}\n\nvar arrowFunction = ()=>{\n\tconsole.log(\"arrowFunction\")\n\t}\n```\n\nYou can pass any of these functions as parameters in other functions.\n```js\nfunction callBackDemo(func1, func2, func3){\n\tfunc1();\n\tfunc2();\n\tfunc3();\n\t}\n\ncallBackDemo(regularFunction, functionExpression, arrowFunction);\n//or you can declare it in the argument itself:\ncallBackDemo(\n\tregularFunction, \n\tregularFunction, \n\t()=>{\n\t\tconsole.log(\"callback declared in the argument\");\n\t})\n```\n### Output\n>\n> regularFunction\n> functionExpression\n> arrowFunction\n> \n> regularFunction\n> regularFunction\n> callback declared in the argument \n>\n\nThis is useful for handling click and other events\nso if we declare a `handleclick` function, for example:\n\n```js\nfunction handleClick(){\n\talert(\"click happened\")\n\t}\n\ndocument.getElementById(\"btn1\").addEventListener(\"click\", handleClick);\n```\n\n## JS is event-driven\nJavascript was built for making the web interactable.\nit therefre keeps listeners for certain events, like button clicks,\nmouseovers, async responses, and many other quircky things. \n\nso in the last example:\n```js\nfunction handleClick(){\n\talert(\"click happened\")\n\t}\n\ndocument.getElementById(\"btn1\").addEventListener(\"click\", handleClick);\n``` \n\nthis will make it so that handleClick is called everytime a person\nclicks button of id `#btn1`. \n\nThis is different than scripting languages where once the program reaches the bottom of the file, it 'dies'. \n\nIn Javascrpit, the alert will not happen UNTIL the button is clicked. \n\nJS keeps its memory open for events when you instruct it to.\n\nlikewise if you run:\n```js\nvar buttonMessage = \"button clicked\";\nconsole.log(\"initial set-up\");\n\nfunction handleClick(){\n\tconsole.log(buttonMessage)\n\t}\n\ndocument.getElementById(\"btn1\").addEventListener(\"click\", handleClick);\n```\n\n### Output:\n> initial set-up\n\nAnd after btn1 is clicked:\n> button clicked\n\nThe second message (\"button clicked\") is the output after a button click, meaning that the entire file does not have to run from the top again (there is no initial set-up message on the console). Javascript keeps the variable in working memory while there is an event listener for it.\n\nThis allows Node to be so performant, making it only call the parts of memory which are necessary to perform for that portion of the application.\n\n## JS keeps its state in Memory after a Function has been executed ([Closures](Closures.md))\n\n\nTake the example of the function above, but wrap it into an initializing function:\n```js\nfunction setUp(){\n\n    var buttonMessage = \"button clicked\";\n\n    console.log(\"initial set-up\");\n\n    function handleClick(){\n        console.log(buttonMessage)\n        }\n\n    document.body.innerHTML += `<button id=\"btn1\">click me!</button>`;\n\n    document.getElementById(\"btn1\").addEventListener(\"click\", handleClick);\n};\n\n//Remember to call it so that everything runs at least once.\nsetUp();\n```\n\nThe outcome is the same as above:\n### Output:\n> initial set-up\n\nAnd after btn1 is clicked:\n> button clicked\n\nThis is incredibly useful because JS only keeps the bits in memory which it needs to. It is calling only the part of the function which it needs (even if the scope of variable `buttonMessage` is not even on the handleclick function);\n\n```js\nfunction setUp(){\n    var buttonClicks = 0;\n\n    function handleClick(){\n        var buttonMessage = `button clicked ${buttonClicks} times`;\n        console.log(buttonMessage);\n\t\tbuttonClicks += 1;\n        }\n\n    document.body.innerHTML += `<button id=\"btn1\">click me!</button>`;\n\n    document.getElementById(\"btn1\").addEventListener(\"click\", handleClick);\n};\n\n//Remember to call it so that everything runs at least once.\nsetUp();\n```\n\n### Output\n\n>button clicked 0 times\n>button clicked 1 times\n>button clicked 2 times\n>button clicked 3 times\n>button clicked 4 times\n>button clicked 5 times\n>button clicked 6 times\n>button clicked 7 times\n\nThe problem with this is that it can leave a lot of things in memory, which we might want to avoid in a large application to ensure performance. \n\nIf that is the case, you can run:\n```js \ndocument.getElementById(\"btn1\").removeEventListener(\"click\", handleClick);\n```\nto free that memory space back up (garbage collection).\n\n**Closure** is a refrence to the place in memory that is kept 'alive' after the the function has finished running (even if it will not be called again)\n\n## [[Scope]]\nJavaScript allows you to call variables ",
  "featured": false
}